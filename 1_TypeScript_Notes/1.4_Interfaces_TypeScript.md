# TypeScript Interfaces

Create file interface.ts, also dont for get to access your html file and connect interface.js into the script src.

Locate into interface .ts file and create a function called ```showToDo```, which has a object  parameter of ```todo``` with a ```title``` that has a *Value Type* of string, and ```text``` also with a *Value Type* of string.

```Ruby
function showToDo(todo: {title:string, text:string}) {

} 
```

Using template literal, lets log ```todo.title``` with ```:``` then the ```todo.title``` within the function.

Create a ```let``` variable called ```myToDo``` equal to a object with a "key" ```title``` that has a "value" of lets say ```trash```, then we specify "key" ```text``` that has a "value" of "take out trash".

Now Call ```showToDo``` and pass our varible ```myToDo``` into it.

```Ruby
function showToDo(todo: {title:string, text:string}) {  #// parameter is object with two arguments

    console.log(`${todo.title}: ${todo.text}`)  #// when called todo is the object
}

let myTodo = {title: "trash", text: "Take out trash bro"} #// assigning object values to variable.

showToDo(myTodo);   #// called function using my variable objects 
```

Yet we can make our code even cleaner, lets first comment our code out and insert name ```interface```, then we're going to call it ```Todo```, which is a block statment.

Within our ```Todo``` block, we have to say ```title``` has *Value Type* of string, and ```text``` has *Value Type* of string.

Outside the Todo block lets past in our ```showToDo``` function and reassign its object block to the interface class we creted ```Todo```.

```Ruby
export interface Todo {
  title: string;
  text: string;
}

function showToDo(todo: Todo) {

  console.log(`${todo.title}: ${todo.text}`)
}

let myTodo = {title: "trash", text: "Take out trash bro"}

showToDo(myTodo);

```


